Awesome foundation. Here’s a tight audit + upgrades so your webhook platform is “merchant-grade” and easy for Target/Macy’s/Shopify-style teams to adopt—without changing your product logic.

---

# Quick audit (what’s great)

* **Clear lifecycle coverage** (create → pickup → transit → delivered → processed → refund).
* **Good namespacing** using dots.
* **Security basics present** (HMAC, retries, logging, per-merchant endpoints).

# High-impact fixes (do these first)

1. **Normalize event taxonomy**

   * Remove duplicates/ambiguity: `return.assigned` vs `driver.assigned` → keep **one** (`return.assigned`, include `driver_id` in payload).
   * Make all actors **fields**, not event families: prefer `return.status_updated` + `actor: "driver"` *only if you truly need a generic status event*. Otherwise keep your explicit events (clearer for merchants).
   * Keep **one domain root per resource**: `return.*`, `pickup.*`, `refund.*`, `driver.*`, `customer.*`.

2. **Versioning from day one**

   * Add header `ReturnIt-Webhook-Version: 2025-09-01` and `event_version: "v1"` in payload.
   * Never break fields inside a version; add new fields with defaults; publish a changelog.

3. **Idempotency & ordering**

   * Every delivery has **immutable** `event_id` (UUID), `delivery_id`, `sequence` (monotonic per `return_id`).
   * Merchants de-dupe by `event_id`; they can reorder using `sequence`.
   * Include `occurred_at` (event time) and `sent_at` (delivery time).

4. **Retry, DLQ, replays**

   * Retries with **exponential backoff + jitter**: e.g., 1m, 5m, 20m, 1h, 6h, 24h (cap).
   * After max attempts, push to **Dead-Letter Queue** (DLQ) and expose a “Replay” button per merchant with `since=cursor` replay API.

5. **Security hardening**

   * Signature header like Stripe:
     `ReturnIt-Signature: t=1695850000,v1=hex(hmac_sha256(secret, t + "." + body))`
     Verify timestamp within 5 min; constant-time compare.
   * Support **secret rotation** (two active secrets).
   * Optional mTLS allowlist for enterprises.

6. **Merchant ergonomics**

   * **Self-serve portal**: add/update endpoints, select events, see logs, test send, replay, rotate secret.
   * **Event filters** (by retailer, region, sandbox/live).
   * **Schema docs + examples** per event with JSON samples.

---

# Proposed canonical event map (deduped)

**Order/Return lifecycle**

* `return.created`
* `return.confirmed`
* `return.assigned` *(includes `driver_id`)*
* `return.in_transit`
* `return.en_route_to_store`
* `return.arrived_at_store`
* `return.delivered`
* `return.processed`
* `return.completed`
* `return.cancelled`
* `return.failed` *(reason codes)*

**Pickup**

* `pickup.scheduled`
* `pickup.eta_updated`
* `pickup.started`
* `pickup.arrived`
* `pickup.completed`
* `pickup.failed` *(reason codes)*

**Refunds**

* `refund.initiated`
* `refund.processing`
* `refund.completed`
* `refund.failed`

**Actors & comms (keep only if merchants truly need them)**

* `customer.notified`
* `customer.updated`
* `driver.location_updated` *(rate-limited/batched)*
* `driver.status_updated` *(“on_duty”, “off_duty”, etc.)*

> Drop `driver.assigned` (redundant with `return.assigned`) and `return.driver_abandoned` (emit `pickup.failed` or `return.failed` with `failure_code="driver_abandoned"`).

---

# Unified payload schema (use this for every event)

```json
{
  "id": "evt_01HZ…",               // event_id (UUID)
  "type": "pickup.arrived",
  "event_version": "v1",
  "api_version": "2025-09-01",
  "occurred_at": "2025-09-26T19:10:23Z",
  "sent_at": "2025-09-26T19:10:24Z",
  "sequence": 42,                   // per-return monotonic sequence
  "attempt": 3,                     // delivery attempt counter
  "merchant_id": "merch_abc123",
  "data": {
    "return": {
      "id": "ret_123",
      "status": "pickup_arrived",
      "retailer": "Target",
      "customer_id": "cus_789",
      "order_value": 58.99,
      "items": [{"sku":"SKU123","qty":1}]
    },
    "pickup": {
      "id": "pku_456",
      "scheduled_start": "2025-09-26T18:30:00Z",
      "scheduled_end": "2025-09-26T19:30:00Z",
      "eta": "2025-09-26T19:08:00Z",
      "address": { "line1":"123 Main", "city":"St Louis","state":"MO","zip":"63141" }
    },
    "driver": {
      "id": "drv_555",
      "lat": 38.643,
      "lng": -90.247
    }
  }
}
```

**Headers**

* `ReturnIt-Event: pickup.arrived`
* `ReturnIt-Webhook-Version: 2025-09-01`
* `ReturnIt-Delivery-Id: dly_01HZ…`
* `ReturnIt-Signature: t=…,v1=…`

**Failure codes (standardize)**

* `INVALID_LABEL`, `STORE_REFUSED`, `NO_SHOW_CUSTOMER`, `NO_SHOW_DRIVER`, `ADDRESS_UNREACHABLE`, `MERCHANT_5XX`, `CUSTOMER_CANCELLED`, `PAYMENT_FAILED`.

---

# Example signatures (Node/TS)

```ts
import crypto from "crypto";

export function sign(secret: string, timestamp: number, body: string) {
  const payload = `${timestamp}.${body}`;
  return crypto.createHmac("sha256", secret).update(payload).digest("hex");
}

export function verify(header: string, secret: string, body: string, toleranceSec = 300) {
  // header: t=1695850000,v1=abcdef...
  const parts = Object.fromEntries(header.split(",").map(x => x.split("=")));
  const t = Number(parts["t"]);
  const v1 = parts["v1"];
  if (!t || !v1) return false;
  if (Math.abs(Date.now()/1000 - t) > toleranceSec) return false;
  const expected = sign(secret, t, body);
  return crypto.timingSafeEqual(Buffer.from(v1), Buffer.from(expected));
}
```

---

# Observability & SLAs (what merchants will ask for)

* **Dashboard:** deliveries timeline, success %, median latency, top failure codes.
* **SLO:** 99.9% delivery success (with retries), P50 < 2s, P95 < 10s.
* **Alerting:** email/webhook to merchant when failure rate > X% over 10 min.
* **Replay API:** `POST /v1/webhooks/replay { merchant_id, since, events: [...] }`.

---

# Data minimization & compliance

* Avoid PII where not needed (no full phone numbers unless the event requires it).
* Provide **masked** fields + internal IDs, and a per-merchant setting “include PII: on/off.”
* Document retention (e.g., raw payloads kept 30 days; logs 90 days).

---

# Suggested docs layout (so integrators can go live in a day)

1. **Quickstart:** receive + verify + ack (200).
2. **Events Reference:** one page per event with JSON sample + field table.
3. **Security:** HMAC spec, rotation, IP ranges (if any), mTLS option.
4. **Retries/Idempotency:** algorithm, max attempts, DLQ, replay.
5. **Change Log & Versioning:** deprecation policy, dates.
6. **Tools:** “Send test event,” replay, logs, secret rotation.

---

# Your current events mapped (rename/merge suggestions)

* Keep: all `return.*`, `pickup.*`, `refund.*`, `customer.notified`, `customer.updated`, `driver.location_updated`, `driver.status_updated`.
* Merge: `return.assigned` **covers** `driver.assigned`.
* Replace: `return.driver_abandoned` → `pickup.failed` with `failure_code="NO_SHOW_DRIVER"`.
* Optional: add `return.photo_captured` if you send photo proof to merchants.

---

# Bonus: merchant contract “done-for-you” defaults

* **Delivery contract:** At-least-once delivery, events can arrive out of order, dedupe by `event_id`, order by `sequence`.
* **Ack contract:** Merchant must return `2xx` within **10s**; otherwise you’ll retry.
* **Rate limiting:** You’ll batch `driver.location_updated` to max 1/min per return to avoid storms.
* **Sandbox:** `/sandbox` endpoints + test secrets, canned event generators.

---

# Why this matters for acquisition

This closes the usual enterprise gaps (versioning, idempotency, replay, DLQ, rotation, PII switches). It makes ReturnIt “drop-in ready” for a DoorDash/Shopify integration team and strengthens the narrative that you **own the category and the integration standard**.

If you want, I can convert this into a **public “Webhooks v1” spec page** with code samples (Node/Python) and a minimal “Send Test Event” widget so merchants can verify within minutes.
