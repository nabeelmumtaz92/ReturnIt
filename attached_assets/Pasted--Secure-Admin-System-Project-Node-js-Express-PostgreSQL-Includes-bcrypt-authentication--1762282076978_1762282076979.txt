// Secure Admin System Project (Node.js + Express + PostgreSQL)
// Includes bcrypt authentication, JWT session control, rate limiting, and offline break-glass reset

// Folder structure:
// secure-admin/
// ├── package.json
// ├── .env.example
// ├── db.js
// ├── server.js
// ├── config/public.pem
// ├── routes/authRoutes.js
// ├── routes/resetRoutes.js
// └── middleware/auth.js

// --- package.json ---
// {
//   "name": "secure-admin",
//   "version": "1.0.0",
//   "type": "module",
//   "main": "server.js",
//   "scripts": { "start": "node server.js" },
//   "dependencies": {
//     "bcrypt": "^5.1.1",
//     "crypto": "^1.0.1",
//     "dotenv": "^16.4.0",
//     "express": "^4.19.2",
//     "jsonwebtoken": "^9.0.2",
//     "pg": "^8.11.3",
//     "rate-limiter-flexible": "^2.5.3"
//   }
// }

// --- .env.example ---
// PORT=4000
// DATABASE_URL=postgresql://user:password@localhost:5432/secure_admin
// JWT_SECRET=change_this_long_secret_key
// PUBLIC_KEY_PATH=./config/public.pem

// --- db.js ---
import pkg from 'pg';
import dotenv from 'dotenv';
dotenv.config();
const { Pool } = pkg;
export const pool = new Pool({ connectionString: process.env.DATABASE_URL });

// --- middleware/auth.js ---
import { RateLimiterMemory } from 'rate-limiter-flexible';
const limiter = new RateLimiterMemory({ points: 5, duration: 60 });
export const rateLimiterMiddleware = async (req, res, next) => {
  try { await limiter.consume(req.ip); next(); }
  catch { res.status(429).json({ error: 'Too many attempts. Try again later.' }); }
};

// --- routes/authRoutes.js ---
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { pool } from '../db.js';
import dotenv from 'dotenv';
import { rateLimiterMiddleware } from '../middleware/auth.js';
dotenv.config();
const router = express.Router();

router.post('/login', rateLimiterMiddleware, async (req, res) => {
  const { password } = req.body;
  const result = await pool.query('SELECT * FROM admin_users WHERE id = 1');
  const user = result.rows[0];
  if (!user) return res.status(404).json({ error: 'Admin not found' });
  const valid = await bcrypt.compare(password, user.password_hash);
  if (!valid) return res.status(401).json({ error: 'Invalid password' });
  const token = jwt.sign({ id: user.id, token_version: user.token_version }, process.env.JWT_SECRET, { expiresIn: '2h' });
  res.json({ token });
});

router.post('/change-password', async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ error: 'Unauthorized' });
  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const { currentPassword, newPassword } = req.body;
    const result = await pool.query('SELECT * FROM admin_users WHERE id=$1', [decoded.id]);
    const user = result.rows[0];
    const match = await bcrypt.compare(currentPassword, user.password_hash);
    if (!match) return res.status(401).json({ error: 'Invalid current password' });
    const newHash = await bcrypt.hash(newPassword, 12);
    await pool.query('UPDATE admin_users SET password_hash=$1, token_version=token_version+1 WHERE id=$2', [newHash, decoded.id]);
    res.json({ message: 'Password changed successfully.' });
  } catch { res.status(401).json({ error: 'Invalid or expired token' }); }
});
export default router;

// --- routes/resetRoutes.js ---
import fs from 'fs';
import crypto from 'crypto';
import express from 'express';
import bcrypt from 'bcrypt';
import { pool } from '../db.js';
import dotenv from 'dotenv';
dotenv.config();
const router2 = express.Router();
const PUBLIC_KEY = fs.readFileSync(process.env.PUBLIC_KEY_PATH || './config/public.pem', 'utf8');
function verifySignature(payloadBuffer, signatureBase64) {
  const signature = Buffer.from(signatureBase64, 'base64');
  return crypto.verify('sha256', payloadBuffer, PUBLIC_KEY, signature);
}
router2.post('/reset-signed', async (req, res) => {
  try {
    const { payload, signature } = req.body;
    if (!payload || !signature) return res.status(400).json({ error: 'Missing data' });
    const payloadBuffer = Buffer.from(JSON.stringify(payload));
    if (!verifySignature(payloadBuffer, signature)) return res.status(401).json({ error: 'Invalid signature' });
    const { iat, exp, nonce, purpose, newPassword } = payload;
    const now = Math.floor(Date.now() / 1000);
    if (!iat || !exp || exp < now || purpose !== 'reset') return res.status(400).json({ error: 'Invalid payload' });
    const nonceCheck = await pool.query('SELECT used FROM reset_nonces WHERE nonce=$1', [nonce]);
    if (nonceCheck.rowCount && nonceCheck.rows[0].used) return res.status(400).json({ error: 'Nonce already used' });
    const newHash = await bcrypt.hash(newPassword, 12);
    await pool.query('UPDATE admin_users SET password_hash=$1, token_version=token_version+1 WHERE id=1', [newHash]);
    await pool.query('INSERT INTO reset_nonces (nonce, used, expires_at) VALUES ($1, TRUE, NOW()) ON CONFLICT (nonce) DO UPDATE SET used=TRUE', [nonce]);
    res.json({ message: 'Password reset successfully via signed token.' });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Internal error' });
  }
});
export default router2;

// --- server.js ---
import express from 'express';
import dotenv from 'dotenv';
import authRoutes from './routes/authRoutes.js';
import resetRoutes from './routes/resetRoutes.js';
dotenv.config();
const app = express();
app.use(express.json());
app.use('/admin', authRoutes);
app.use('/admin', resetRoutes);
app.listen(process.env.PORT || 4000, () => console.log(`Secure Admin running on port ${process.env.PORT || 4000}`));

// --- SQL schema ---
// CREATE TABLE admin_users (
//   id SERIAL PRIMARY KEY,
//   password_hash TEXT NOT NULL,
//   token_version INTEGER DEFAULT 1,
//   created_at TIMESTAMP DEFAULT NOW()
// );
// CREATE TABLE reset_nonces (
//   nonce TEXT PRIMARY KEY,
//   used BOOLEAN DEFAULT FALSE,
//   created_at TIMESTAMP DEFAULT NOW(),
//   expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '10 minutes'
// );
